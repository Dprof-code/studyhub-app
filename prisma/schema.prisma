// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// ─────────────────────────────────────────────────────────────
//  StudyHub - Prisma schema  •  PostgreSQL
// ─────────────────────────────────────────────────────────────

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ───────────── Enums ─────────────
enum UserRole {
  STUDENT
  LECTURER
  ADMIN
}

enum AuthProvider {
  PASSWORD
  GOOGLE
}

enum ReactionType {
  LIKE
  DISLIKE
  LOVE
  HAHA
  WOW
  SAD
  ANGRY
}

enum ModActionType {
  APPROVE
  REJECT
}

// AI Processing Enums
enum ProcessingStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum QuestionDifficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

// ───────────── Core Identity ─────────────
model User {
  id           Int         @id @default(autoincrement())
  userId       String      @default(uuid())
  email        String      @unique
  firstname    String
  lastname     String
  name         String? // Combined display name
  username     String      @unique
  avatarUrl    String?
  avatar       String? // Alternative avatar field
  bio          String?
  role         UserRole    @default(STUDENT)
  level        Int?
  year         Int? // Academic year
  gender       String? // For matching preferences
  department   Department? @relation(fields: [departmentId], references: [id])
  departmentId Int?
  faculty      Faculty?    @relation(fields: [facultyId], references: [id])
  facultyId    Int?

  resources     Resource[]
  credentials   Credential[]
  synopsisEdits CourseSynopsisHistory[]

  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  Thread           Thread[]
  Post             Post[]
  Reaction         Reaction[]
  Report           Report[]
  ModerationAction ModerationAction[]
  ResourceComment  ResourceComment[]

  // Peer Matching & Chat
  matchRequests   MatchRequest[]
  sentMatches     Match[]        @relation("UserMatches")
  receivedMatches Match[]        @relation("MatchedUserMatches")
  chatRooms       ChatRoom[]     @relation("ChatParticipants")
  chatMessages    ChatMessage[]
  lastSeen        DateTime?

  // Gamification Relations
  stats                UserStats?
  activityLogs         ActivityLog[]
  userAchievements     UserAchievement[]
  contentVotes         ContentVote[]
  leaderboardEntries   LeaderboardEntry[]
  challengeCompletions DailyChallengeCompletion[]
  badges               UserBadge[]

  // Course Enrollment
  enrollments Enrollment[]

  // AI & Analytics Relations
  userInteractions   UserInteraction[]
  studyPlans         StudyPlan[]
  studySessions      StudySession[]
  gamificationEvents GamificationEvent[]
  courseAnalyses     CourseAnalysis[]

  // Notification Relations
  notifications             Notification[]
  notificationSubscriptions NotificationSubscription[]
  notificationPreferences   NotificationPreference?
}

model Credential {
  id           Int          @id @default(autoincrement())
  provider     AuthProvider
  providerId   String
  passwordHash String?
  userId       Int
  user         User         @relation(fields: [userId], references: [id])

  @@unique([provider, providerId])
}

// ───────────── Academic Structure ─────────────
model Department {
  id        Int      @id @default(autoincrement())
  code      String   @unique
  name      String   @unique
  courses   Course[]
  users     User[]
  faculty   Faculty  @relation(fields: [facultyId], references: [id])
  facultyId Int

  // Gamification Relations
  leaderboardEntries LeaderboardEntry[]

  createdAt DateTime @default(now())
}

// ───────────── Faculty ─────────────
model Faculty {
  id          Int          @id @default(autoincrement())
  name        String       @unique
  departments Department[]
  users       User[]

  createdAt DateTime @default(now())
}

model Course {
  id           Int        @id @default(autoincrement())
  code         String     @unique
  title        String
  synopsis     String     @db.Text
  level        Int        @default(100) // Default level set to 100
  departmentId Int
  department   Department @relation(fields: [departmentId], references: [id])
  createdAt    DateTime   @default(now())

  resources       Resource[]
  synopsisHistory CourseSynopsisHistory[]
  Thread          Thread[]
  enrollments     Enrollment[]

  // AI & Analytics Relations
  studySessions  StudySession[]
  courseAnalyses CourseAnalysis[]
}

model CourseSynopsisHistory {
  id        Int      @id @default(autoincrement())
  content   String   @db.Text
  courseId  Int
  course    Course   @relation(fields: [courseId], references: [id])
  userId    Int
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@index([courseId])
  @@index([userId])
}

// ───────────── Course Enrollment ─────────────
enum EnrollmentStatus {
  ACTIVE
  COMPLETED
  DROPPED
  PENDING
}

model Enrollment {
  id             Int              @id @default(autoincrement())
  userId         Int
  courseId       Int
  status         EnrollmentStatus @default(ACTIVE)
  enrolledAt     DateTime         @default(now())
  completedAt    DateTime?
  grade          String? // Final grade if completed
  isAutoEnrolled Boolean          @default(false) // Track if auto-enrolled

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@unique([userId, courseId]) // Prevent duplicate enrollments
  @@index([userId])
  @@index([courseId])
  @@index([status])
}

// ───────────── Resource Repository ─────────────
model Resource {
  id          Int               @id @default(autoincrement())
  title       String
  description String?
  fileUrl     String
  fileType    String
  uploaderId  Int
  uploader    User              @relation(fields: [uploaderId], references: [id])
  courseId    Int
  courseName  String?
  course      Course            @relation(fields: [courseId], references: [id])
  tags        Tag[]             @relation("ResourcesOnTags")
  year        Int?
  createdAt   DateTime          @default(now())
  Report      Report[]
  comments    ResourceComment[]

  // AI & RAG System Fields
  isPastQuestion     Boolean             @default(false)
  aiProcessingStatus ProcessingStatus?
  ragContent         String?             @db.Text // Processed content for RAG
  extractedQuestions ExtractedQuestion[]
  conceptMappings    ConceptResource[]
  aiProcessingJobs   AIProcessingJob[]

  // Gamification Relations
  votes ContentVote[]

  // AI & Analytics Relations  
  userInteractions UserInteraction[]
}

model Tag {
  id        Int        @id @default(autoincrement())
  name      String     @unique
  resources Resource[] @relation("ResourcesOnTags")
}

model ResourceComment {
  id         Int               @id @default(autoincrement())
  content    String
  resourceId Int
  resource   Resource          @relation(fields: [resourceId], references: [id])
  authorId   Int
  author     User              @relation(fields: [authorId], references: [id])
  parentId   Int?
  parent     ResourceComment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies    ResourceComment[] @relation("CommentReplies")
  createdAt  DateTime          @default(now())

  // Gamification Relations
  votes ContentVote[]

  @@index([resourceId])
  @@index([authorId])
}

// ───────────── Forums & Reactions ─────────────
model Thread {
  id         Int      @id @default(autoincrement())
  title      String
  courseId   Int
  course     Course   @relation(fields: [courseId], references: [id])
  authorId   Int
  author     User     @relation(fields: [authorId], references: [id])
  posts      Post[]
  isStickied Boolean  @default(false)
  isLocked   Boolean  @default(false)
  createdAt  DateTime @default(now())
}

model Post {
  id          Int      @id @default(autoincrement())
  content     String
  authorId    Int
  author      User     @relation(fields: [authorId], references: [id])
  threadId    Int
  thread      Thread   @relation(fields: [threadId], references: [id])
  parentId    Int?
  parent      Post?    @relation("PostReplies", fields: [parentId], references: [id])
  replies     Post[]   @relation("PostReplies")
  attachments String[] @default([])

  reactions Reaction[]
  reports   Report[]
  createdAt DateTime   @default(now())

  // Gamification Relations
  votes ContentVote[]
}

model Reaction {
  id        Int          @id @default(autoincrement())
  type      ReactionType
  postId    Int
  post      Post         @relation(fields: [postId], references: [id])
  userId    Int
  user      User         @relation(fields: [userId], references: [id])
  createdAt DateTime     @default(now())

  @@unique([postId, userId, type])
}

// ───────────── Moderation ─────────────
model Report {
  id         Int       @id @default(autoincrement())
  reporterId Int
  reporter   User      @relation(fields: [reporterId], references: [id])
  reason     String
  resourceId Int?
  resource   Resource? @relation(fields: [resourceId], references: [id])
  postId     Int?
  post       Post?     @relation(fields: [postId], references: [id])
  handled    Boolean   @default(false)
  createdAt  DateTime  @default(now())

  action ModerationAction?
}

model ModerationAction {
  id          Int           @id @default(autoincrement())
  reportId    Int           @unique
  report      Report        @relation(fields: [reportId], references: [id])
  moderatorId Int
  moderator   User          @relation(fields: [moderatorId], references: [id])
  action      ModActionType
  note        String?
  createdAt   DateTime      @default(now())
}

// ───────────── Peer Matching & Chat ─────────────
enum MatchRequestStatus {
  active
  matched
  cancelled
  expired
}

enum MatchStatus {
  pending
  connected
  declined
}

enum StudyFormat {
  online
  in_person
  hybrid
}

enum StudyLevel {
  beginner
  intermediate
  advanced
}

enum PreferredGender {
  any
  same
  opposite
}

enum ChatRoomType {
  direct
  group
}

enum MessageType {
  text
  image
  file
}

model MatchRequest {
  id                 String             @id @default(uuid())
  userId             Int
  user               User               @relation(fields: [userId], references: [id])
  subjects           String[] // Array of selected topics/subjects
  availability       String[] // Array of time slots
  studyFormat        StudyFormat
  maxGroupSize       Int                @default(4)
  studyLevel         StudyLevel
  preferredGender    PreferredGender    @default(any)
  locationPreference String?
  additionalNotes    String?
  stayAvailable      Boolean            @default(false) // Whether user wants to stay available for matching
  status             MatchRequestStatus @default(active)
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  @@index([userId])
  @@index([status])
  @@index([studyFormat])
}

model Match {
  id            String      @id @default(uuid())
  userId        Int // Person who sent the connect request
  user          User        @relation("UserMatches", fields: [userId], references: [id])
  matchedUserId Int // Person who received the connect request
  matchedUser   User        @relation("MatchedUserMatches", fields: [matchedUserId], references: [id])
  status        MatchStatus @default(pending)
  message       String? // Optional message when connecting
  chatRoomId    String?
  chatRoom      ChatRoom?   @relation(fields: [chatRoomId], references: [id])
  connectedAt   DateTime? // When both users connected
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@unique([userId, matchedUserId])
  @@index([userId])
  @@index([matchedUserId])
  @@index([status])
}

model ChatRoom {
  id           String        @id @default(uuid())
  name         String? // Display name for the chat
  type         ChatRoomType  @default(direct)
  members      User[]        @relation("ChatParticipants")
  messages     ChatMessage[]
  matches      Match[]
  lastActivity DateTime      @default(now())
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  @@index([type])
  @@index([lastActivity])
}

model ChatMessage {
  id          String           @id @default(uuid())
  content     String           @db.Text
  type        MessageType      @default(text)
  senderId    Int
  sender      User             @relation(fields: [senderId], references: [id])
  chatRoomId  String
  chatRoom    ChatRoom         @relation(fields: [chatRoomId], references: [id])
  attachments ChatAttachment[]
  createdAt   DateTime         @default(now())

  @@index([chatRoomId])
  @@index([senderId])
  @@index([createdAt])
}

model ChatAttachment {
  id        String      @id @default(uuid())
  name      String
  url       String
  type      String // MIME type
  size      Int // File size in bytes
  messageId String
  message   ChatMessage @relation(fields: [messageId], references: [id])
  createdAt DateTime    @default(now())

  @@index([messageId])
}

// ───────────── AI & RAG System ─────────────

model ExtractedQuestion {
  id             Int                @id @default(autoincrement())
  resourceId     Int
  resource       Resource           @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  questionText   String             @db.Text
  questionNumber String?
  marks          Int?
  difficulty     QuestionDifficulty @default(MEDIUM)
  aiAnalysis     Json? // Store AI-generated metadata
  createdAt      DateTime           @default(now())

  // Relationships
  concepts QuestionConcept[]

  @@index([resourceId])
  @@index([difficulty])
}

model Concept {
  id              Int       @id @default(autoincrement())
  name            String    @unique
  description     String?
  category        String // e.g., "Mathematics", "Physics", "Computer Science"
  parentConceptId Int?
  parent          Concept?  @relation("ConceptHierarchy", fields: [parentConceptId], references: [id])
  children        Concept[] @relation("ConceptHierarchy")
  aiSummary       String?   @db.Text // Generated explanations
  createdAt       DateTime  @default(now())

  // Relationships
  questions QuestionConcept[]
  resources ConceptResource[]

  @@index([category])
  @@index([parentConceptId])
}

model QuestionConcept {
  id            Int               @id @default(autoincrement())
  questionId    Int
  question      ExtractedQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)
  conceptId     Int
  concept       Concept           @relation(fields: [conceptId], references: [id], onDelete: Cascade)
  confidence    Float             @default(0.0) // AI confidence score (0.0 to 1.0)
  isMainConcept Boolean           @default(false)

  @@unique([questionId, conceptId])
  @@index([questionId])
  @@index([conceptId])
  @@index([confidence])
}

model ConceptResource {
  id               Int      @id @default(autoincrement())
  conceptId        Int
  concept          Concept  @relation(fields: [conceptId], references: [id], onDelete: Cascade)
  resourceId       Int
  resource         Resource @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  relevanceScore   Float    @default(0.0) // Relevance score (0.0 to 1.0)
  extractedContent String?  @db.Text // Relevant sections from the resource
  createdAt        DateTime @default(now())

  @@unique([conceptId, resourceId])
  @@index([conceptId])
  @@index([resourceId])
  @@index([relevanceScore])
}

model AIProcessingJob {
  id           String           @id @default(uuid())
  resourceId   Int
  resource     Resource         @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  status       ProcessingStatus @default(PENDING)
  progress     Int              @default(0) // 0-100 percentage
  results      Json? // Processing results
  errorMessage String?
  startedAt    DateTime?
  completedAt  DateTime?
  createdAt    DateTime         @default(now())

  @@index([resourceId])
  @@index([status])
  @@index([createdAt])
}

// ───────────── Gamification & Reputation System ─────────────

// Points & Experience System
enum ActivityType {
  RESOURCE_UPLOAD
  RESOURCE_DOWNLOAD
  COURSE_CREATION
  COMMENT_HELPFUL
  DISCUSSION_PARTICIPATION
  UPVOTE_RECEIVED
  EXPERT_ENDORSEMENT
  DAILY_LOGIN
  THREAD_CREATION
  POST_CREATION
  RESOURCE_COMMENT
  PEER_HELP
  QUALITY_CONTRIBUTION
}

enum AchievementCategory {
  LEARNING
  SOCIAL
  QUALITY
  CONSISTENCY
  MILESTONE
  SEASONAL
}

enum AchievementTier {
  BRONZE
  SILVER
  GOLD
  PLATINUM
  LEGENDARY
}

enum VoteType {
  UPVOTE
  HELPFUL
  EXPERT_APPROVAL
  QUALITY_CONTENT
}

enum ReputationTier {
  NEWCOMER // 0-50
  CONTRIBUTOR // 51-200  
  VALUED_MEMBER // 201-500
  COMMUNITY_LEADER // 501-1000
  EXPERT_CONTRIBUTOR // 1000+
}

model UserStats {
  id     Int  @id @default(autoincrement())
  userId Int  @unique
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Core Stats
  totalXP         Int            @default(0)
  reputationScore Int            @default(0)
  currentLevel    Int            @default(1)
  reputationTier  ReputationTier @default(NEWCOMER)

  // Activity Counters
  resourceUploads    Int @default(0)
  threadsCreated     Int @default(0)
  postsCreated       Int @default(0)
  commentsCreated    Int @default(0)
  upvotesReceived    Int @default(0)
  expertEndorsements Int @default(0)

  // Quality Metrics
  averageContentRating Float @default(0.0)
  helpfulVotes         Int   @default(0)
  qualityScore         Int   @default(0)

  // Engagement Metrics
  loginStreak        Int       @default(0)
  longestLoginStreak Int       @default(0)
  lastLoginDate      DateTime?
  totalLoginDays     Int       @default(0)

  // Social Metrics
  peersHelped        Int @default(0)
  mentorshipPoints   Int @default(0)
  collaborationScore Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([reputationScore])
  @@index([currentLevel])
  @@index([reputationTier])
}

model ActivityLog {
  id               Int          @id @default(autoincrement())
  userId           Int
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  activityType     ActivityType
  xpGained         Int          @default(0)
  reputationGained Int          @default(0)
  description      String?

  // Context References
  resourceId   Int?
  threadId     Int?
  postId       Int?
  targetUserId Int? // For peer interactions

  metadata  Json? // Additional activity context
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([activityType])
  @@index([createdAt])
}

model Achievement {
  id               Int                 @id @default(autoincrement())
  name             String              @unique
  description      String
  category         AchievementCategory
  tier             AchievementTier     @default(BRONZE)
  iconUrl          String?
  xpReward         Int                 @default(0)
  reputationReward Int                 @default(0)

  // Unlock Conditions
  requiredActions Json // Flexible condition system
  isActive        Boolean   @default(true)
  isSecret        Boolean   @default(false) // Hidden until unlocked
  isSeasonal      Boolean   @default(false)
  seasonStartDate DateTime?
  seasonEndDate   DateTime?

  // Progressive Achievement Support
  parentId Int? // For multi-tier achievements
  parent   Achievement?  @relation("AchievementProgression", fields: [parentId], references: [id])
  children Achievement[] @relation("AchievementProgression")

  userAchievements UserAchievement[]
  createdAt        DateTime          @default(now())

  @@index([category])
  @@index([tier])
  @@index([isActive])
}

model UserAchievement {
  id            Int         @id @default(autoincrement())
  userId        Int
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievementId Int
  achievement   Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)
  progress      Float       @default(0.0) // 0.0 to 1.0 for partial progress
  unlockedAt    DateTime? // null if still in progress
  createdAt     DateTime    @default(now())

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([unlockedAt])
}

model ContentVote {
  id         Int      @id @default(autoincrement())
  voterId    Int
  voter      User     @relation(fields: [voterId], references: [id], onDelete: Cascade)
  voteType   VoteType
  voteWeight Int      @default(1) // Based on voter's reputation

  // Content References (one of these will be set)
  resourceId Int?
  resource   Resource?        @relation(fields: [resourceId], references: [id], onDelete: Cascade)
  postId     Int?
  post       Post?            @relation(fields: [postId], references: [id], onDelete: Cascade)
  commentId  Int?
  comment    ResourceComment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([voterId, resourceId, voteType])
  @@unique([voterId, postId, voteType])
  @@unique([voterId, commentId, voteType])
  @@index([voterId])
  @@index([voteType])
}

model LeaderboardEntry {
  id           Int         @id @default(autoincrement())
  userId       Int
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  category     String // 'overall', 'weekly', 'monthly', 'department', etc.
  period       String // 'current', '2024-09', 'all-time', etc.
  score        Int
  rank         Int
  departmentId Int?
  department   Department? @relation(fields: [departmentId], references: [id])

  // Metadata
  calculatedAt DateTime @default(now())

  @@unique([userId, category, period])
  @@index([category, period, rank])
  @@index([departmentId])
}

model DailyChallenge {
  id          Int      @id @default(autoincrement())
  title       String
  description String
  targetDate  DateTime @unique // Date this challenge is for

  // Challenge Requirements
  requiredActivity ActivityType
  targetCount      Int          @default(1)
  xpReward         Int          @default(5)
  reputationReward Int          @default(2)

  // Challenge Status
  isActive Boolean @default(true)

  completions DailyChallengeCompletion[]
  createdAt   DateTime                   @default(now())

  @@index([targetDate])
  @@index([isActive])
}

model DailyChallengeCompletion {
  id          Int            @id @default(autoincrement())
  userId      Int
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  challengeId Int
  challenge   DailyChallenge @relation(fields: [challengeId], references: [id], onDelete: Cascade)
  completedAt DateTime       @default(now())

  @@unique([userId, challengeId])
  @@index([userId])
  @@index([completedAt])
}

// Enhanced Badge System (extends existing concept)
enum BadgeType {
  MERIT
  ROLE
  EXPERT
  ACHIEVEMENT // New: Achievement-based badges
  SEASONAL // New: Time-limited badges
}

model Badge {
  id          Int       @id @default(autoincrement())
  name        String    @unique
  description String
  type        BadgeType
  iconUrl     String?
  color       String? // Hex color for badge display

  // Requirements
  requiredLevel        Int?
  requiredReputation   Int?
  requiredAchievements String[] // Achievement IDs needed

  // Status
  isActive   Boolean @default(true)
  isRare     Boolean @default(false)
  maxHolders Int? // Limit total badge holders

  userBadges UserBadge[]
  createdAt  DateTime    @default(now())

  @@index([type])
  @@index([isActive])
}

model UserBadge {
  id        Int      @id @default(autoincrement())
  userId    Int
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId   Int
  badge     Badge    @relation(fields: [badgeId], references: [id], onDelete: Cascade)
  awardedBy Int? // Who awarded this badge (for role badges)
  awardedAt DateTime @default(now())
  isVisible Boolean  @default(true) // User can choose to hide badges

  @@unique([userId, badgeId])
  @@index([userId])
  @@index([awardedAt])
}

// ───────────── AI & Analytics Models ─────────────

model UserInteraction {
  id              Int      @id @default(autoincrement())
  userId          Int
  interactionType String // SEARCH, DOWNLOAD, VIEW, etc.
  resourceId      Int?
  metadata        Json? // Additional data about the interaction
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  resource Resource? @relation(fields: [resourceId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([interactionType])
  @@index([createdAt])
  @@map("user_interactions")
}

model StudyPlan {
  id             Int      @id @default(autoincrement())
  userId         Int
  title          String
  goals          String[] // Study goals
  timeframe      String // week, month, semester
  estimatedHours Int // Total estimated study hours
  plan           Json // AI-generated study plan structure
  status         String   @default("ACTIVE") // ACTIVE, COMPLETED, PAUSED
  progress       Float    @default(0.0) // Progress percentage
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@map("study_plans")
}

model StudySession {
  id          Int      @id @default(autoincrement())
  userId      Int
  duration    Int // Duration in minutes
  courseId    Int?
  resourceIds Int[] // Resources studied in this session
  concepts    String[] // Concepts covered
  notes       String? // Optional session notes
  createdAt   DateTime @default(now())

  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  course Course? @relation(fields: [courseId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([courseId])
  @@index([createdAt])
  @@map("study_sessions")
}

model GamificationEvent {
  id          Int      @id @default(autoincrement())
  userId      Int
  eventType   String // XP_EARNED, BADGE_AWARDED, LEVEL_UP, etc.
  xpAwarded   Int      @default(0)
  description String? // Human-readable description
  metadata    Json? // Additional event data
  createdAt   DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
  @@map("gamification_events")
}

// Course Analysis Model for Phase 3 AI Processing
model CourseAnalysis {
  id           Int      @id @default(autoincrement())
  userId       Int
  courseId     Int
  analysisType String // CONTENT_STRUCTURE, DIFFICULTY_PROGRESSION, etc.
  results      Json // Analysis results data
  insights     Json // AI-generated insights
  summary      Json // Analysis summary and key metrics
  metadata     Json? // Additional metadata and configuration
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  course Course @relation(fields: [courseId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([courseId])
  @@index([analysisType])
  @@index([createdAt])
  @@map("course_analyses")
}

// ─────────────────────────────────────────────────────────────
//  Phase 7: Notifications & PWA System
// ─────────────────────────────────────────────────────────────

enum NotificationType {
  SYSTEM // System announcements
  ACHIEVEMENT // Badge/achievement unlocked
  STUDY_REMINDER // Study session reminders
  CHAT_MESSAGE // New chat message
  COURSE_UPDATE // Course content updated
  PEER_MATCH // New peer match found
  RESOURCE_SHARED // Resource shared with user
  QUIZ_RESULT // Quiz/assessment completed
  COLLABORATION // Collaboration invite/update
  AI_INSIGHT // New AI-generated insight
  DEADLINE_REMINDER // Assignment/exam deadline
  SOCIAL_ACTIVITY // Social interactions (likes, comments)
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model Notification {
  id       String               @id @default(cuid())
  userId   Int
  type     NotificationType
  status   NotificationStatus   @default(UNREAD)
  priority NotificationPriority @default(NORMAL)

  title      String
  message    String
  actionUrl  String? // Optional URL for action button
  actionText String? // Text for action button

  // Rich notification data (JSON)
  data Json? // Additional structured data

  // Delivery tracking
  delivered   Boolean   @default(false)
  deliveredAt DateTime?
  readAt      DateTime?

  // Scheduling
  scheduledFor DateTime? // For scheduled notifications
  expiresAt    DateTime? // Expiration time

  // Grouping and batching
  groupKey String? // For grouping similar notifications
  batchId  String? // For batch operations

  // Push notification tracking
  pushSent   Boolean  @default(false)
  pushTokens String[] // FCM/VAPID tokens used

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([status])
  @@index([priority])
  @@index([scheduledFor])
  @@index([groupKey])
  @@index([createdAt])
  @@map("notifications")
}

model NotificationSubscription {
  id        String  @id @default(cuid())
  userId    Int
  endpoint  String
  p256dhKey String
  authKey   String
  userAgent String?
  isActive  Boolean @default(true)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  lastUsed  DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, endpoint])
  @@index([userId])
  @@index([isActive])
  @@map("notification_subscriptions")
}

model NotificationPreference {
  id     String @id @default(cuid())
  userId Int    @unique

  // Channel preferences
  emailEnabled Boolean @default(true)
  pushEnabled  Boolean @default(true)
  inAppEnabled Boolean @default(true)

  // Type preferences (JSON object with NotificationType as keys)
  typePreferences Json @default("{}")

  // Timing preferences
  quietHoursStart String? // HH:MM format
  quietHoursEnd   String? // HH:MM format
  timezone        String  @default("UTC")

  // Frequency settings
  digestEnabled   Boolean @default(false)
  digestFrequency String  @default("daily") // daily, weekly
  digestTime      String  @default("09:00") // HH:MM format

  // Batching settings
  batchingEnabled Boolean @default(true)
  batchingDelay   Int     @default(300) // seconds

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notification_preferences")
}
